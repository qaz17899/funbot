"""Import QuestLine data into database.

This script reads quest_lines_data.json (generated by extract_quest_lines.ts) and
imports the data into QuestLineData and QuestData tables.

Usage:
    python scripts/import_quest_lines.py
"""

from __future__ import annotations

import asyncio
import json
import logging
import sys
from pathlib import Path
from typing import Any

# Add project root to path (scripts/importers/ -> funbot root)
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from tortoise import Tortoise

from funbot.db.models.pokemon.quest_line_data import QuestData, QuestLineData
from funbot.db.models.pokemon.route_requirement import RequirementType, RouteRequirement

logging.basicConfig(level=logging.INFO, format="%(message)s")
logger = logging.getLogger(__name__)


# =============================================================================
# REQUIREMENT TYPE MAPPING
# =============================================================================

REQUIREMENT_TYPE_MAP: dict[str, RequirementType] = {
    "RouteKillRequirement": RequirementType.ROUTE_KILL,
    "GymBadgeRequirement": RequirementType.GYM_BADGE,
    "ClearDungeonRequirement": RequirementType.DUNGEON_CLEAR,
    "TemporaryBattleRequirement": RequirementType.TEMP_BATTLE,
    "QuestLineCompletedRequirement": RequirementType.QUEST_LINE_COMPLETED,
    "QuestLineStepCompletedRequirement": RequirementType.QUEST_LINE_STEP,
    "ObtainedPokemonRequirement": RequirementType.OBTAINED_POKEMON,
    "WeatherRequirement": RequirementType.WEATHER,
    "DayOfWeekRequirement": RequirementType.DAY_OF_WEEK,
    "SpecialEventRequirement": RequirementType.SPECIAL_EVENT,
    "OneFromManyRequirement": RequirementType.ONE_FROM_MANY,
    "MultiRequirement": RequirementType.MULTI,
}


# =============================================================================
# REQUIREMENT TREE INSERTION
# =============================================================================


async def create_requirement_tree(
    req_data: dict[str, Any] | None, parent: RouteRequirement | None = None
) -> RouteRequirement | None:
    """Recursively create requirement tree from JSON data.

    Matches the structure used in import_routes.py for consistency.
    """
    if not req_data:
        return None

    req_type_name = req_data.get("type", "")
    req_type = REQUIREMENT_TYPE_MAP.get(req_type_name)

    if req_type is None:
        logger.warning("Unknown requirement type: %s", req_type_name)
        return None

    # Build parameters based on requirement type
    params: dict[str, Any] = {}

    if req_type == RequirementType.ROUTE_KILL:
        params["kills"] = req_data.get("kills", 0)
        params["region"] = req_data.get("region", "kanto")
        params["route"] = req_data.get("route", 0)
    elif req_type == RequirementType.GYM_BADGE:
        params["badge"] = req_data.get("badge", "")
    elif req_type == RequirementType.DUNGEON_CLEAR:
        params["clears"] = req_data.get("clears", 1)
        params["dungeon"] = req_data.get("dungeon", "")
    elif req_type == RequirementType.TEMP_BATTLE:
        params["battle"] = req_data.get("battle", "")
    elif req_type == RequirementType.QUEST_LINE_COMPLETED:
        params["quest"] = req_data.get("questLine", "")
    elif req_type == RequirementType.QUEST_LINE_STEP:
        params["quest"] = req_data.get("questLine", "")
        params["step"] = req_data.get("step", 0)
        if "option" in req_data:
            params["option"] = req_data["option"]
    elif req_type == RequirementType.OBTAINED_POKEMON:
        params["pokemon"] = req_data.get("pokemon", "")

    # Create requirement record
    requirement = await RouteRequirement.create(
        parent=parent,
        route=None,  # Quest line requirements don't link to routes
        requirement_type=req_type.value,
        parameters=params or None,
    )

    # Process children for compound requirements (Multi, OneFromMany)
    children_data = req_data.get("requirements", [])
    for child_data in children_data:
        await create_requirement_tree(child_data, requirement)

    return requirement


# =============================================================================
# MAIN IMPORT LOGIC
# =============================================================================


async def import_quest_lines() -> tuple[int, int]:
    """Import all quest lines from JSON file.

    Returns:
        Tuple of (quest_lines_count, quests_count)
    """
    json_path = Path(__file__).parent.parent / "data" / "quest_lines_data.json"

    if not json_path.exists():
        logger.error("Quest lines data file not found: %s", json_path)
        logger.error("Run 'npx tsx scripts/extract_quest_lines.ts' first")
        return 0, 0

    with Path(json_path).open(encoding="utf-8") as f:
        quest_lines_data = json.load(f)

    logger.info(f"Loaded {len(quest_lines_data)} quest lines from JSON")

    quest_lines_count = 0
    quests_count = 0

    for ql_data in quest_lines_data:
        name = ql_data.get("name", "")
        description = ql_data.get("description", "")
        bulletin_board = ql_data.get("bulletinBoard", "None")
        total_quests = ql_data.get("totalQuests", 0)
        requirements_data = ql_data.get("requirement")

        # Create unlock requirement tree if exists
        root_requirement = await create_requirement_tree(requirements_data)

        # Create quest line record
        quest_line = await QuestLineData.create(
            name=name,
            description=description,
            bulletin_board=bulletin_board,
            total_quests=total_quests,
            root_requirement=root_requirement,
        )
        quest_lines_count += 1

        # Create quests for this quest line
        quests_data = ql_data.get("quests", [])
        for idx, quest_data in enumerate(quests_data):
            quest_type = quest_data.get("type", "Quest")
            quest_description = quest_data.get("description", "")
            amount = quest_data.get("amount", 1)
            points_reward = quest_data.get("pointsReward", 0)
            has_custom_reward = quest_data.get("hasCustomReward", False)

            # Collect type-specific data
            type_data: dict[str, Any] = {}
            for key in [
                "npcName",
                "dungeon",
                "gym",
                "battle",
                "pokemon",
                "shiny",
                "route",
                "region",
                "pokemonType",
            ]:
                if key in quest_data:
                    type_data[key] = quest_data[key]

            # Handle nested quests (MultipleQuestsQuest)
            if "quests" in quest_data:
                type_data["quests"] = quest_data["quests"]

            await QuestData.create(
                quest_line=quest_line,
                quest_index=idx,
                quest_type=quest_type,
                description=quest_description,
                amount=amount,
                points_reward=points_reward,
                type_data=type_data or None,
                has_custom_reward=has_custom_reward,
            )
            quests_count += 1

        logger.info(f"  ‚úì {name} ({len(quests_data)} quests)")

    return quest_lines_count, quests_count


async def main() -> None:
    """Initialize database and run import with transaction wrapper."""
    from tortoise.transactions import in_transaction

    from funbot.db.config import TORTOISE_CONFIG

    logger.info("üéÆ Quest Line Data Importer")
    logger.info("=" * 50)

    # Initialize Tortoise ORM with project config
    await Tortoise.init(config=TORTOISE_CONFIG)

    # safe=True won't drop existing tables
    await Tortoise.generate_schemas(safe=True)

    try:
        # Clear existing quest line data first
        deleted_quests = await QuestData.all().delete()
        deleted_quest_lines = await QuestLineData.all().delete()
        logger.info("Cleared %s quest lines, %s quests", deleted_quest_lines, deleted_quests)

        # Use transaction for atomicity and performance
        async with in_transaction():
            quest_lines_count, quests_count = await import_quest_lines()

        logger.info("=" * 50)
        logger.info("‚úÖ Import complete!")
        logger.info("   Quest Lines: %s", quest_lines_count)
        logger.info("   Quests: %s", quests_count)
    except Exception as e:
        logger.exception("‚ùå Import failed, transaction rolled back: %s", e)
        raise
    finally:
        await Tortoise.close_connections()


if __name__ == "__main__":
    asyncio.run(main())
